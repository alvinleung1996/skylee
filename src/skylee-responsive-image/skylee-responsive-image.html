<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/debounce.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">

<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="skylee-responsive-image">
  <template strip-whitespace>
    <style>
      :host {
        display: block;
      }
      :host([sizing="cover"]),
      :host([sizing="contain"]) {
        position: relative;
      }
      :host([sizing="cover"]) > ::slotted(*),
      :host([sizing="contain"]) > ::slotted(*) {
        position: absolute;
        top: 0px;
        right: 0px;
        bottom: 0px;
        left: 0px;
      }
      :host([sizing="fit-width"]) > ::slotted(*) {
        width: 100%;
      }
      :host([sizing="fit-height"]) > ::slotted(*) {
        height: 100%;
      }
    </style>
    <slot></slot>
  </template>
  <script>
    class SkyleeResponsiveImage extends Polymer.mixinBehaviors(Polymer.IronResizableBehavior, Polymer.Element) {

      static get is() { return 'skylee-responsive-image'; }

      static get properties() { return {
        src: {
          type: String
        },
        srcWidth: {
          type: Number
        },
        srcHeight: {
          type: Number
        },
        elementWidth: {
          type: Number,
          value: -1
        },
        elementHeight: {
          type: Number,
          value: -1
        },
        sizing: {
          type: String,
          value: 'fit-width',
          reflectToAttribute: true
        },
        preventLoad: {
          type: Boolean,
          value: false
        },

        resizeDelay: {
          type: Number,
          value: 200
        },

        computedSrc: {
          type: String,
          readOnly: true,
          notify: true
        },
        computedSrcAttribute: {
          type: String,
          value: 'src'
        },
      };}

      static get observers() { return [
        '_onSrcParamChanged(src, srcWidth, srcHeight, elementWidth, elementHeight, sizing, preventLoad)',
        '_onComputedSrcChanged(computedSrc, computedSrcAttribute)'
      ];}

      ready() {
        super.ready();
        this.addEventListener('iron-resize', e => this._onIronResize(e));
      }

      _onSrcParamChanged(src, srcWidth, srcHeight, elementWidth, elementHeight, sizing, preventLoad) {
        this._computeSrc();
      }

      _onIronResize(evt) {
        this._computeSrcDebouncer = Polymer.Debouncer.debounce(this._computeSrcDebouncer,
          Polymer.Async.timeOut.after(this.resizeDelay),
          () => this._computeSrc()
        );
      }

      _computeSrc() {
        let hostWidth = this.elementWidth < 0 ? this.clientWidth : this.elementWidth;
        let hostHeight = this.elementHeight < 0 ? this.clientHeight : this.elementHeight;
        
        /* Ignore the case when both width and height equal to 0
         * which indicates the element is not visible yet
         * and its src should remain unchanged.
         */
        if (hostWidth > 0 && hostHeight > 0) { 
          let computedSrc = null;
          if (this.src && Number.isInteger(this.srcWidth) && Number.isInteger(this.srcHeight) && !this.preventLoad) {
            // console.log(`w: ${hostWidth}, h: ${hostHeight}`);

            let factor = 1;
            while (true) {
              let nextFactor = factor * 2;
              let nextWidth = Math.round(this.srcWidth / nextFactor);
              let nextHeight = Math.round(this.srcHeight / nextFactor);

              let pass = nextWidth >= 320 && nextHeight >= 320;
              if (this.sizing === 'cover') {
                pass = pass && (nextWidth >= hostWidth && nextHeight >= hostHeight);
              } else if (this.sizing === 'contain') {
                pass = pass && (nextWidth >= hostWidth || nextHeight >= hostHeight);
              } else if (this.sizing === 'fit-width') {
                pass = pass && nextWidth >= hostWidth;
              } else if (this.sizing === 'fit-height') {
                pass = pass && nextHeight >= hostHeight;
              }

              if (pass) {
                factor = nextFactor;
              } else {
                break;
              }
            }

            let matches = this.src.match(/^([\w\.\-\/]+)\.(\w+)$/);
            if (matches !== null) {
              computedSrc = `${matches[1]}-${1 / factor}x.${matches[2]}`;
            }
          }
          this._setComputedSrc(computedSrc);
        }
      }

      _onComputedSrcChanged(src, srcAttribute) {
        let childList = Polymer.FlattenedNodesObserver.getFlattenedNodes(this).filter(n => n.nodeType === Node.ELEMENT_NODE);

        let prevSrcAttribute = this._prevSrcAttribute;
        this._prevSrcAttribute = srcAttribute;

        for (let i = 0, child; child = childList[i]; ++i) {
          if (srcAttribute !== prevSrcAttribute && prevSrcAttribute) {
            child.removeAttribute(prevSrcAttribute);
          }
          if (srcAttribute) {
            if (src) {
              child.setAttribute(srcAttribute, src);
            } else {
              child.removeAttribute(srcAttribute);
            }
          }
        }
      }

    }
    window.customElements.define(SkyleeResponsiveImage.is, SkyleeResponsiveImage);
  </script>
</dom-module>